diff -uNrp plp_vanilla/reference/plp-2.2/hw//build/build_500k_skeleton/top.ucf plp/reference/plp-2.2/hw//build/build_500k_skeleton/top.ucf
--- plp_vanilla/reference/plp-2.2/hw//build/build_500k_skeleton/top.ucf	2011-03-17 13:38:43.150770001 -0500
+++ plp/reference/plp-2.2/hw//build/build_500k_skeleton/top.ucf	2011-03-17 13:52:38.160770002 -0500
@@ -90,19 +90,6 @@ NET "mod_vga_rgb<7>" LOC = "r8";
 NET "mod_vga_hs" LOC = "t4";
 NET "mod_vga_vs" LOC = "u3";
 
-NET "mod_gpio_gpio<0>"  LOC = "l15";
-NET "mod_gpio_gpio<1>"  LOC = "k12";
-NET "mod_gpio_gpio<2>"  LOC = "l17";
-NET "mod_gpio_gpio<3>"  LOC = "m15";
-NET "mod_gpio_gpio<4>"  LOC = "k13";
-NET "mod_gpio_gpio<5>"  LOC = "l16";
-NET "mod_gpio_gpio<6>"  LOC = "m14";
-NET "mod_gpio_gpio<7>"  LOC = "m16";
-NET "mod_gpio_gpio<8>"  LOC = "m13";
-NET "mod_gpio_gpio<9>"  LOC = "r18";
-NET "mod_gpio_gpio<10>" LOC = "r15";
-NET "mod_gpio_gpio<11>" LOC = "t17";
-NET "mod_gpio_gpio<12>" LOC = "p17";
-NET "mod_gpio_gpio<13>" LOC = "r16";
-NET "mod_gpio_gpio<14>" LOC = "t18";
-NET "mod_gpio_gpio<15>" LOC = "u18";
+NET "mod_plpbot_uart_txd_0" LOC = "l15";
+NET "mod_plpbot_uart_txd_1" LOC = "k12";
+
diff -uNrp plp_vanilla/reference/plp-2.2/hw//verilog/arbiter.v plp/reference/plp-2.2/hw//verilog/arbiter.v
--- plp_vanilla/reference/plp-2.2/hw//verilog/arbiter.v	2011-03-17 13:38:43.150770001 -0500
+++ plp/reference/plp-2.2/hw//verilog/arbiter.v	2011-03-17 15:20:25.690770002 -0500
@@ -17,7 +17,7 @@
  */
 
 
-module arbiter(rst, clk, cpu_daddr, cpu_bus_data, bus_cpu_data, cpu_drw, cpu_iaddr, bus_cpu_inst, mod_leds_leds, mod_uart_txd, mod_uart_rxd, mod_switches_switches, mod_sseg_an, mod_sseg_display, cpu_stall, mod_sram_clk, mod_sram_adv, mod_sram_cre, mod_sram_ce, mod_sram_oe, mod_sram_we, mod_sram_lb, mod_sram_ub, mod_sram_data, mod_sram_addr, mod_vga_rgb, mod_vga_hs, mod_vga_vs, mod_gpio_gpio);
+module arbiter(rst, clk, cpu_daddr, cpu_bus_data, bus_cpu_data, cpu_drw, cpu_iaddr, bus_cpu_inst, mod_leds_leds, mod_uart_txd, mod_uart_rxd, mod_switches_switches, mod_sseg_an, mod_sseg_display, cpu_stall, mod_sram_clk, mod_sram_adv, mod_sram_cre, mod_sram_ce, mod_sram_oe, mod_sram_we, mod_sram_lb, mod_sram_ub, mod_sram_data, mod_sram_addr, mod_vga_rgb, mod_vga_hs, mod_vga_vs, mod_plpbot_uart_txd_0);
 	input clk, rst;
 
 	/* cpu i/o */
@@ -38,7 +38,7 @@ module arbiter(rst, clk, cpu_daddr, cpu_
 	output [23:1] mod_sram_addr;
 	output [7:0] mod_vga_rgb;
 	output mod_vga_hs, mod_vga_vs;
-	inout [15:0] mod_gpio_gpio;
+	output mod_plpbot_uart_txd_0;
 
 	/* inter-module interconnect */
 	wire [31:0] mod_vga_sram_addr;
@@ -58,22 +58,22 @@ module arbiter(rst, clk, cpu_daddr, cpu_
 	wire mod2_ie = imod == 2;
 	wire mod3_ie = imod == 3;
 	wire mod4_ie = imod == 4;
-	wire mod5_ie = imod == 5;
 	wire mod6_ie = imod == 6;
 	wire mod7_ie = imod == 7;
 	wire mod8_ie = imod == 8;
 	wire mod9_ie = imod == 9;
+	wire mod10_ie = imod == 10;
 
 	wire mod0_de = dmod == 0;
 	wire mod1_de = dmod == 1;
 	wire mod2_de = dmod == 2;
 	wire mod3_de = dmod == 3;
 	wire mod4_de = dmod == 4;
-	wire mod5_de = dmod == 5;
 	wire mod6_de = dmod == 6;
 	wire mod7_de = dmod == 7;
 	wire mod8_de = dmod == 8;
 	wire mod9_de = dmod == 9;
+	wire mod10_de = dmod == 10;
 
 	/* the bus muxes */
 	wire [31:0] mod0_inst, mod0_data;
@@ -81,11 +81,11 @@ module arbiter(rst, clk, cpu_daddr, cpu_
 	wire [31:0] mod2_inst, mod2_data;
 	wire [31:0] mod3_inst, mod3_data;
 	wire [31:0] mod4_inst, mod4_data;
-	wire [31:0] mod5_inst, mod5_data;
 	wire [31:0] mod6_inst, mod6_data;
 	wire [31:0] mod7_inst, mod7_data;
 	wire [31:0] mod8_inst, mod8_data;
 	wire [31:0] mod9_inst, mod9_data;
+	wire [31:0] mod10_inst, mod10_data;
 
 	assign bus_cpu_inst = 
 		mod0_ie ? mod0_inst :
@@ -93,11 +93,11 @@ module arbiter(rst, clk, cpu_daddr, cpu_
 		mod2_ie ? mod2_inst :
 		mod3_ie ? mod3_inst :
 		mod4_ie ? mod4_inst :
-		mod5_ie ? mod5_inst :
 		mod6_ie ? mod6_inst :
 		mod7_ie ? mod7_inst :
 		mod8_ie ? mod8_inst :
-		mod9_ie ? mod9_inst : 0;
+		mod9_ie ? mod9_inst :
+		mod10_ie ? mod10_inst : 0;
 
 	assign bus_cpu_data = 
 		mod0_de ? mod0_data :
@@ -105,11 +105,11 @@ module arbiter(rst, clk, cpu_daddr, cpu_
 		mod2_de ? mod2_data :
 		mod3_de ? mod3_data :
 		mod4_de ? mod4_data :
-		mod5_de ? mod5_data :
 		mod6_de ? mod6_data :
 		mod7_de ? mod7_data :
 		mod8_de ? mod8_data :
-		mod9_de ? mod9_data : 0;
+		mod9_de ? mod9_data :
+		mod10_de ? mod10_data : 0;
 
 	/* module instantiations */
 	/* 0 */ mod_rom		rom_t		(rst, clk, mod0_ie, mod0_de, ieff_addr, deff_addr, cpu_drw, cpu_bus_data, mod0_inst, mod0_data);
@@ -117,9 +117,12 @@ module arbiter(rst, clk, cpu_daddr, cpu_
 	/* 2 */ mod_uart	uart_t		(rst, clk, mod2_ie, mod2_de, ieff_addr, deff_addr, cpu_drw, cpu_bus_data, mod2_inst, mod2_data, mod_uart_txd, mod_uart_rxd);
 	/* 3 */ mod_switches 	switches_t 	(rst, clk, mod3_ie, mod3_de, ieff_addr, deff_addr, cpu_drw, cpu_bus_data, mod3_inst, mod3_data, mod_switches_switches);
 	/* 4 */ mod_leds	leds_t    	(rst, clk, mod4_ie, mod4_de, ieff_addr, deff_addr, cpu_drw, cpu_bus_data, mod4_inst, mod4_data, mod_leds_leds);
-	/* 5 */ mod_gpio	gpio_t		(rst, clk, mod5_ie, mod5_de, ieff_addr, deff_addr, cpu_drw, cpu_bus_data, mod5_inst, mod5_data, mod_gpio_gpio);
+	
+
 	/* 6 */ mod_vga		vga_t		(rst, clk, mod6_ie, mod6_de, ieff_addr, deff_addr, cpu_drw, cpu_bus_data, mod6_inst, mod6_data, mod_vga_rgb, mod_vga_hs, mod_vga_vs, mod_vga_sram_data, mod_vga_sram_addr, mod_vga_sram_read, mod_vga_sram_rdy);
 	/* 7 */ mod_plpid	plpid_t   	(rst, clk, mod7_ie, mod7_de, ieff_addr, deff_addr, cpu_drw, cpu_bus_data, mod7_inst, mod7_data);
 	/* 8 */ mod_timer	timer_t	  	(rst, clk, mod8_ie, mod8_de, ieff_addr, deff_addr, cpu_drw, cpu_bus_data, mod8_inst, mod8_data);
 	/* 9 */ mod_sseg	sseg_t		(rst, clk, mod9_ie, mod9_de, ieff_addr, deff_addr, cpu_drw, cpu_bus_data, mod9_inst, mod9_data, mod_sseg_an, mod_sseg_display);
+	
+	/* 10 */mod_plpbot_uart plpbot_uart_t_0	(rst, clk, mod10_ie, mod10_de, ieff_addr, deff_addr, cpu_drw, cpu_bus_data, mod10_inst, mod10_data, mod_plpbot_uart_txd_0, 1'b1);
 endmodule
diff -uNrp plp_vanilla/reference/plp-2.2/hw//verilog/mm.v plp/reference/plp-2.2/hw//verilog/mm.v
--- plp_vanilla/reference/plp-2.2/hw//verilog/mm.v	2011-03-17 13:38:43.160770002 -0500
+++ plp/reference/plp-2.2/hw//verilog/mm.v	2011-03-17 15:19:36.010770001 -0500
@@ -55,6 +55,7 @@ module mm(addr, mod, eff_addr);
 		     (addr[31:20] == 12'hf05) ? 7 : /* mod_plpid */
 		     (addr[31:20] == 12'hf06) ? 8 : /* mod_timer */
 		     (addr[31:20] == 12'hf0a) ? 9 : /* mod_sseg */
+		     (addr[31:20] == 12'hf0b) ? 10 : /* plpbot uart 0 */
 		     0;
 	assign eff_addr = (mod == 8'h01) ? {8'h00,addr[23:0]} : {12'h000,addr[19:0]};
 endmodule
diff -uNrp plp_vanilla/reference/plp-2.2/hw//verilog/mod_plpbot_uart.v plp/reference/plp-2.2/hw//verilog/mod_plpbot_uart.v
--- plp_vanilla/reference/plp-2.2/hw//verilog/mod_plpbot_uart.v	1969-12-31 18:00:00.000000000 -0600
+++ plp/reference/plp-2.2/hw//verilog/mod_plpbot_uart.v	2011-03-17 13:42:27.150770009 -0500
@@ -0,0 +1,207 @@
+/*
+    Copyright 2010 David Fritz, Brian Gordon, Wira Mulia
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+ */
+
+
+/* 
+David Fritz
+
+rs232 uart module
+
+2.10.2010
+*/
+
+/*
+The uart is 9600 8N1
+
+There are four words in the uart memory map:
+0x00: command register
+0x04: status register
+0x08: receive buffer
+0x0c: send buffer
+
+COMMAND REGISTER:
+	always reads 0
+	writing 0x01 will initiate a transfer of the lower byte of the send buffer
+	writing 0x02 will clear the ready flag
+	writing 0x03 will transfer the send buffer and clear the ready flag
+
+STATUS REGISTER:
+	{30'b0,rdy,cts}
+	The rdy bit indicates that a new byte is available on the receive buffer (clear by sending 0x02 to the command register)
+	The cts bit indicates that the previous transfer is complete and the uart is clear to send another byte
+
+RECEIVE BUFFER:
+	Lower byte contains the received data
+
+SEND BUFFER:
+	Lower byte contains data to be sent
+
+*/
+module mod_plpbot_uart(rst, clk, ie, de, iaddr, daddr, drw, din, iout, dout, txd, rxd);
+        input rst;
+        input clk;
+        input ie,de;
+        input [31:0] iaddr, daddr;
+        input drw;
+        input [31:0] din;
+        output [31:0] iout, dout;
+	output txd;
+	input rxd;
+
+        /* by spec, the iout and dout signals must go hiZ when we're not using them */
+        wire [31:0] idata, ddata;
+        assign iout = idata;
+        assign dout = ddata;
+
+	/* hopefully the machine never tries to execute off of the uart, so we'll zero the idata line */
+	assign idata = 32'h00000000;
+
+	/* the uart */
+	wire data_rdy,cts,send,clear;
+	wire [7:0] in_buffer;
+	reg [7:0] out_buffer;
+	plpbot_uart_core uart(clk,rxd,txd,in_buffer,out_buffer,data_rdy,clear,cts,send,rst);
+	
+	assign send = (de && drw && daddr == 32'h0) ? din[0] : 0;
+	assign clear = (de && drw && daddr == 32'h0) ? din[1] : 0;
+
+	assign ddata = (daddr == 32'h0) ? 0 : /* command reg */
+			  (daddr == 32'h4) ? {30'h0,data_rdy,cts} : /* status */
+			  (daddr == 32'h8) ? {24'h0,in_buffer} : /* receive */
+			  (daddr == 32'hc) ? {24'h0,out_buffer} : 0; /* transmit */
+	
+	/* all data bus activity is negative edge triggered */
+	always @(negedge clk) begin
+		if (de && drw && daddr == 32'hc) /* write a new byte to the output buffer */
+			out_buffer = din[7:0];
+	end
+endmodule
+
+module plpbot_uart_baud_generator(clk,baud,baud16,rst);
+	input clk,rst;
+	output baud;
+	output baud16;
+	
+	parameter b_rate = 9600;
+	parameter c_rate = 25000000; /* 25 Mhz */
+	parameter divider = c_rate / b_rate;
+	parameter divider16 = c_rate / (16 * b_rate); /* 16 times faster! */
+	
+	reg [31:0] count,count16;
+	
+	assign baud = (count == 0) ? 1 : 0;
+	assign baud16 = (count16 == 0) ? 1 : 0;
+	
+	always @(negedge clk) begin
+		count = count + 1;
+		count16 = count16 + 1;
+		if (count == divider)
+			count = 0;
+		if (count16 == divider16) 
+			count16 = 0;
+		if (rst) begin
+			count = 0;
+			count16 = 0;
+		end
+	end
+endmodule
+
+module plpbot_uart_core(clk,rxd,txd,in_buffer,out_buffer,data_rdy,clear,cts,send,rst);
+	input clk,rst;
+	input rxd;
+	input clear;
+	output reg [7:0] in_buffer;
+	output reg data_rdy;
+	output cts;
+	input [7:0] out_buffer;
+	input send;
+	output txd;
+	
+	wire baud;
+	wire baud16;
+	plpbot_uart_baud_generator ubg(clk,baud,baud16,rst);
+
+	/* receive core */
+	reg [3:0] rxd_state;
+	reg [3:0] baud16_space;
+	wire baud16_mark = (baud16_space == 0) ? 1 : 0;
+
+	always @(negedge clk) begin
+		if (rst) begin
+			data_rdy <= 0;
+			rxd_state <= 0;
+		end else if (baud16) begin
+			if (rxd_state != 0) /* work */
+				baud16_space <= baud16_space + 1;
+			else
+				baud16_space <= 15;
+
+			case (rxd_state)
+				0: if (!rxd) rxd_state <= 1; /* start bit */
+				1: if (baud16_mark) rxd_state <= 2; 
+				2: if (baud16_mark) begin rxd_state <= 3; in_buffer[0] <= rxd; end /* data bits */
+				3: if (baud16_mark) begin rxd_state <= 4; in_buffer[1] <= rxd; end /* data bits */
+				4: if (baud16_mark) begin rxd_state <= 5; in_buffer[2] <= rxd; end /* data bits */
+				5: if (baud16_mark) begin rxd_state <= 6; in_buffer[3] <= rxd; end /* data bits */
+				6: if (baud16_mark) begin rxd_state <= 7; in_buffer[4] <= rxd; end /* data bits */
+				7: if (baud16_mark) begin rxd_state <= 8; in_buffer[5] <= rxd; end /* data bits */
+				8: if (baud16_mark) begin rxd_state <= 9; in_buffer[6] <= rxd; end /* data bits */
+				9: if (baud16_mark) begin rxd_state <= 10; in_buffer[7] <= rxd; end /* data bits */
+				10: if (baud16_mark & rxd) begin rxd_state <= 0; data_rdy <= 1; end
+				default: if (baud16_mark) rxd_state <= 0;
+			endcase
+		end
+		if (clear)
+			data_rdy <= 0;
+	end
+	
+	/* transmit core */
+	reg [3:0] txd_state;
+	assign cts = (txd_state == 0) ? 1 : 0;
+	always @(negedge clk) begin
+		if (baud) begin
+			case (txd_state)
+				1: txd_state = 2; /* start bit */
+				2: txd_state = 3; /* data bits */
+				3: txd_state = 4;
+				4: txd_state = 5;
+				5: txd_state = 6;
+				6: txd_state = 7;
+				7: txd_state = 8;
+				8: txd_state = 9;
+				9: txd_state = 10;
+				10: txd_state = 0;
+				default: txd_state = 0; /* stop bit and idle */
+			endcase
+		end
+		if (send)
+			txd_state = 1;
+	end
+	
+	assign txd = (txd_state == 0) ? 1 : /* idle / stop */
+					 (txd_state == 1) ? 1 : /* idle / stop */
+					 (txd_state == 2) ? 0 : /* start bit */
+					 (txd_state == 3) ? out_buffer[0] : 
+					 (txd_state == 4) ? out_buffer[1] : 
+					 (txd_state == 5) ? out_buffer[2] : 
+					 (txd_state == 6) ? out_buffer[3] : 
+					 (txd_state == 7) ? out_buffer[4] : 
+					 (txd_state == 8) ? out_buffer[5] : 
+					 (txd_state == 9) ? out_buffer[6] : 
+					 (txd_state == 10) ? out_buffer[7] : 1;
+endmodule
diff -uNrp plp_vanilla/reference/plp-2.2/hw//verilog/top.v plp/reference/plp-2.2/hw//verilog/top.v
--- plp_vanilla/reference/plp-2.2/hw//verilog/top.v	2011-03-17 13:38:43.160770002 -0500
+++ plp/reference/plp-2.2/hw//verilog/top.v	2011-03-17 15:20:49.800770000 -0500
@@ -25,7 +25,7 @@ top level module for mips design
 2.6.2010
 */
 
-module top(clk,leds,rst,txd,rxd,switches,sseg_an,sseg_display, mod_sram_clk, mod_sram_adv, mod_sram_cre, mod_sram_ce, mod_sram_oe, mod_sram_we, mod_sram_lb, mod_sram_ub, mod_sram_data, mod_sram_addr, mod_vga_rgb, mod_vga_hs, mod_vga_vs, mod_gpio_gpio);
+module top(clk,leds,rst,txd,rxd,switches,sseg_an,sseg_display, mod_sram_clk, mod_sram_adv, mod_sram_cre, mod_sram_ce, mod_sram_oe, mod_sram_we, mod_sram_lb, mod_sram_ub, mod_sram_data, mod_sram_addr, mod_vga_rgb, mod_vga_hs, mod_vga_vs, mod_plpbot_uart_txd_0);
 	input clk;
 	output [7:0] leds;
 	input rst,rxd;
@@ -38,7 +38,7 @@ module top(clk,leds,rst,txd,rxd,switches
 	output [23:1] mod_sram_addr;	
 	output [7:0] mod_vga_rgb;
 	output mod_vga_hs, mod_vga_vs;
-	inout [15:0] mod_gpio_gpio;
+	output mod_plpbot_uart_txd_0;
 
 	wire [31:0] daddr, dout, din, iaddr, iin;
 	wire drw;
@@ -46,7 +46,7 @@ module top(clk,leds,rst,txd,rxd,switches
 
 	clock c_t(clk, c);
 	cpu cpu_t(rst, c, cpu_stall, daddr, dout, din, drw, iaddr, iin);
-        arbiter arbiter_t(rst, c, daddr, dout, din, drw, iaddr, iin, leds, txd, rxd, switches, sseg_an, sseg_display, cpu_stall, mod_sram_clk, mod_sram_adv, mod_sram_cre, mod_sram_ce, mod_sram_oe, mod_sram_we, mod_sram_lb, mod_sram_ub, mod_sram_data, mod_sram_addr, mod_vga_rgb, mod_vga_hs, mod_vga_vs, mod_gpio_gpio);
+        arbiter arbiter_t(rst, c, daddr, dout, din, drw, iaddr, iin, leds, txd, rxd, switches, sseg_an, sseg_display, cpu_stall, mod_sram_clk, mod_sram_adv, mod_sram_cre, mod_sram_ce, mod_sram_oe, mod_sram_we, mod_sram_lb, mod_sram_ub, mod_sram_data, mod_sram_addr, mod_vga_rgb, mod_vga_hs, mod_vga_vs, mod_plpbot_uart_txd_0);
 endmodule
 	
 
